<html xmlns="http://www.w3.org/TR/REC-html40">

<head>
<meta http-equiv=Content-Type content="text/html; charset=windows-1252">
<title>MIDI File Printer Architecture</title>
</head>

<body>

<h1>MIDI File Printer Architecture</h1>

<p>This document will give you some help if you want to make changes to the MIDI File
Printer source code.</p>

<h2>Two Platforms</h2>

<p>One important thing comes from the history: the MIDI File Printer was developed first
on Atari TOS and – since I don’t like to throw away my own work – the current
sources still are mutli-platform sources:</p>

<ul>
 <li>Platform 1: Atari TOS</li>
 <li>Platform 2: wxWidgets</li>
</ul>

<p>On Atari I
used a pure C compiler called Pure C, and on wxWidgets a C++ compiler. On Atari
I used the GUI builder ACS and on wxWidgets none. On Atari the complex drawing
functions must use the VDI (<u>v</u>irtual <u>d</u>evice <u>i</u>nterface) and
on wxWidgets the wxDC (<u>d</u>evice <u>c</u>ontext) interface. Despite these enormous
differences most of the code is common for the 2 platforms. How can this be achieved ?</p>

<ol>
 <li>write code that compiles as C and as C++, e.g. don’t use // comments</li>
 <li>use standard C library functions where available (e.g. fopen() in common/profile.c 
     instead of wxFile)</li>
 <li>emulate the necessary part of the Atari VDI</li>
 <li>ok, there are some #ifdef
     __PUREC__ in the common code. The Pure C compiler defines __PUREC__.</li>
</ol>

<p>The GUI layer however was implemented twice: once on ACS and once on wxWidgets.</p>

<p><img src="/dbimage.php?id=188674" alt=""/></p>

<p>The figure above shows how the drawing functions are kept common. There are a lot of
drawing functions: one draws a whole page, one a track, one a note, another one
the background and so on. They all use some of the VDI functions to perform
their tasks. VDI functions normally start with v_. See <a
href="VDI-doc/NVDI.txt">here</a> for the documentation of the commercial VDI
replacement NVDI. The VDI is a part of GEM, the <u>g</u>raphics <u>e</u>nvironment
<u>m</u>anager, an operating system layer for graphics input (mouse hardware,
windows) and output. A good abstract can be found in the <a
href="http://en.wikipedia.org/wiki/GEM_Desktop">Wikipedia</a>.</p>

<p>You need not to learn anything about the VDI except when to call which of the API
functions if you want to implement a new drawing function. The drawing
functions of the MIDI File Pinter get a void pointer on wxWidgets and a 32 bit
integer (handle) on Atari TOS. The rest of the code is common.</p>

<p>On wxWidgets the void pointer must point to a VirtualDevice object. The
VirtualDevice class is part of the my_libs (my libraries) project that comes
together with the MIDI File Printer sources. The VirtualDevice class is part of
my mini VDI emulation and holds some state information a real VDI can keep
itself (e.g. draw areas with perimeter or without), but a wxDC keeps not. The
VirtualDevice object extends the state memory of the wxWidgets so that it is a
superset of what wxDC and what VDI remember from call to call. The
VirtualDevice constructor wants a wxDC pointer as input. Thus, together with
the VirtualDevice pointer, the wxDC is forwarded to the v_...()
functions, the 2<sup>nd</sup> part of the VDI emulation. The v_...() may remember and/or retrieve state information in/from
the VirtualDevice object and/or call appropriate wxDC methods to perform
drawing, set the text font, etc. That’s the whole story.</p>

<p>On Atari the 32 bit integer consists of two 16 bit integers. The least significant one
is the real VDI handle that came from v_opn[v]wk()
calls. The most significant one is an extension by me and holds the information
whether the screen mode is high or true colour or a palette mode. Some drawing
functions behave differently on the screen mode. For example draw_note() 
may draw a pink area in high colour mode and an area
with a red-white pattern in palette mode.</p>

<h2>Producing MIDI File Printers For Other Operating Systems</h2>

<p>The wxWidgets code part has been produced and tested on 32 bit Windows and 
Ubuntu Linux (andLinux). It will not be a big work to port it to other UNIXes or Mac OS X.</p>

<h2>GUI Architecture Details</h2>


<p>The next figure shows how the information a main window shows is represented by a 
<b>DOCUMENT</b> structure. When the MIDI file is read, a <b>track
table</b> is generated by the parser function. This track table is part of the
document structure. The <b>layout</b>
substructure is filled before the first drawing takes place. It contains
information on how the notes and staves shall be placed on the page(s). A 3<sup>rd</sup>
substructure contains the parameters that a stored in an accompanying .MI$ 
<b>profile</b>.</p>

<p><b>INFO_DB</b>, <b>FILTER_DB</b> and <b>PARAMS_DB</b> are read and modified
by the corresponding windows. A topped main window tells the file information,
parameters and filter windows that it is the new top window by calling the
corresponding set_database() functions. For example
the filter window will get a pointer to the FILTER_DB part of the main window’s
DOCUMENT structure. A null pointer means that no MIDI
file was loaded or (Atari version only) that there is no main window at all.</p>

<p><img src="/dbimage.php?id=188673"/></p>

<p>On Atari the 32 bit integer consists of two 16 bit integers. The least significant one
is the real VDI handle that came from v_opn[v]wk()
calls. The most significant one is an extension by me and holds the information
whether the screen mode is high or true colour or a palette mode. Some drawing
functions behave differently on the screen mode. For example draw_note() 
may draw a pink area in high colour mode and an area
with a red-white pattern in palette mode.</p>

<h2>Colour Schemes</h2>

<p>The beautiful colour schemes are represented by COLOR_SCHEME structures in memory
and by SCHEME_FILE structures on disk. Both structures contain the same
information, but because of historical reasons the SCHEME_FILE structure is
bigger and contains unused gaps. The SCHEME_FILE is copied to/from disk, i.e.
the file format is binary. Because of the little/big endian difference, for 16
bit fields the bytes are swapped on Intel platforms when they are copied to or
read from the COLOR_SCHEME structure (there are no bigger fields). This way,
the same colour scheme files can be used on little and big endian processors.</p>

<p>The colour values are stored as 15 bit RGBs inside 16 bit integers regardless of the
screen mode:</p>

<p>
<pre>       highest bit unused | 5 bits blue | 5 bits green | 5 bits red </pre>
</p>

<p>They must be transformed to 24 bit RGBs (inside 32 bit integers) for wxWidgets. This is
done in the VDI emulation layer (see above) by the vs_color()
function. I.e. the MIDI File Printer drawing functions work with 15 bit RGBs.</p>

<p>On Atari TOS the 15 bit RGBs are either used directly (in direct colour mode) or mapped
to palette colours (2, 4, 16, 256 colour palettes are supported) with the help
of the rgb_to_index() and index_to_rgb() functions.</p>

<h2>Possible Code Improvements</h2>

<p>Here are some items that could be improved, but aren’t really urgent:</p>

<ul>
 <li>Use wxSizer for all window layouts.</li>
 <li>The byte order of the binary
     colour scheme files is determined by the platform currently. This is
     decided during compilation already and when more platforms should be
     supported the pre-processor constructs would become ugly. It would be
     better to detect the byte order automatically from a byte order flag in
     the scheme file - or to use a text format instead of a binary format.</li>
</ul>

</body>

</html>
